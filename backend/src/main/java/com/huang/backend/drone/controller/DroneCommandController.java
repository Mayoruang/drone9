package com.huang.backend.drone.controller;

import com.huang.backend.drone.dto.DroneCommandDto;
import com.huang.backend.drone.dto.DroneCommandRequestDto;
import com.huang.backend.drone.dto.DroneCommandResponseDto;
import com.huang.backend.drone.service.DroneCommandService;

import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;
import java.util.UUID;

/**
 * Controller for drone command operations (Remote Control functionality)
 */
@Slf4j
@RestController
@RequestMapping("/api/v1/drones/{droneId}/commands")
@RequiredArgsConstructor
public class DroneCommandController {

    private final DroneCommandService droneCommandService;

    /**
     * Send a custom command to a drone
     * 
     * @param droneId the ID of the target drone
     * @param request the command request
     * @param authentication the authenticated user (optional)
     * @return command response
     */
    @PostMapping
    public ResponseEntity<DroneCommandResponseDto> sendCommand(
            @PathVariable UUID droneId,
            @Valid @RequestBody DroneCommandRequestDto request,
            Authentication authentication) {
        
        String username = authentication != null ? authentication.getName() : "anonymous";
        log.info("üéØ ÊéßÂà∂Âô®Êî∂Âà∞ÂëΩ‰ª§ËØ∑Ê±Ç:");
        log.info("   - Êó†‰∫∫Êú∫ID: {}", droneId);
        log.info("   - Âä®‰Ωú: {}", request.getAction());
        log.info("   - ÂèÇÊï∞: {}", request.getParameters());
        log.info("   - Áî®Êà∑: {}", username);
        log.info("Sending command {} to drone {} by user {}", 
                request.getAction(), droneId, username);
        
        log.info("üî• ÊéßÂà∂Âô®Âç≥Â∞ÜË∞ÉÁî® droneCommandService.sendCommand()...");
        DroneCommandResponseDto response = droneCommandService.sendCommand(
                droneId, request, username);
        log.info("‚úÖ ÊéßÂà∂Âô®Êî∂Âà∞ÊúçÂä°ÂìçÂ∫î: success={}, message={}", response.isSuccess(), response.getMessage());
        
        return ResponseEntity.ok(response);
    }

    /**
     * Send a raw JSON command to a drone (for advanced users)
     * 
     * @param droneId the ID of the target drone
     * @param rawCommand the raw command as JSON
     * @param authentication the authenticated user (optional)
     * @return command response
     */
    @PostMapping("/raw")
    public ResponseEntity<DroneCommandResponseDto> sendRawCommand(
            @PathVariable UUID droneId,
            @RequestBody Map<String, Object> rawCommand,
            Authentication authentication) {
        
        String username = authentication != null ? authentication.getName() : "anonymous";
        log.info("Sending raw command to drone {} by user {}", droneId, username);
        
        // Convert raw command to DroneCommandRequestDto
        DroneCommandRequestDto request = DroneCommandRequestDto.builder()
                .action((String) rawCommand.get("action"))
                .parameters((Map<String, Object>) rawCommand.get("parameters"))
                .priority((Integer) rawCommand.getOrDefault("priority", 5))
                .timeoutSeconds((Integer) rawCommand.getOrDefault("timeoutSeconds", 30))
                .cancellable((Boolean) rawCommand.getOrDefault("cancellable", true))
                .build();
        
        DroneCommandResponseDto response = droneCommandService.sendCommand(
                droneId, request, username);
        
        return ResponseEntity.ok(response);
    }

    /**
     * Emergency stop command
     * 
     * @param droneId the ID of the target drone
     * @param authentication the authenticated user (optional)
     * @return command response
     */
    @PostMapping("/emergency-stop")
    public ResponseEntity<DroneCommandResponseDto> emergencyStop(
            @PathVariable UUID droneId,
            Authentication authentication) {
        
        String username = authentication != null ? authentication.getName() : "anonymous";
        log.warn("Emergency stop command for drone {} by user {}", droneId, username);
        
        DroneCommandResponseDto response = droneCommandService.emergencyStop(droneId, username);
        return ResponseEntity.ok(response);
    }

    /**
     * Return to home command
     * 
     * @param droneId the ID of the target drone
     * @param authentication the authenticated user (optional)
     * @return command response
     */
    @PostMapping("/return-to-home")
    public ResponseEntity<DroneCommandResponseDto> returnToHome(
            @PathVariable UUID droneId,
            Authentication authentication) {
        
        String username = authentication != null ? authentication.getName() : "anonymous";
        log.info("Return to home command for drone {} by user {}", droneId, username);
        
        DroneCommandResponseDto response = droneCommandService.returnToHome(droneId, username);
        return ResponseEntity.ok(response);
    }

    /**
     * Land command
     * 
     * @param droneId the ID of the target drone
     * @param authentication the authenticated user (optional)
     * @return command response
     */
    @PostMapping("/land")
    public ResponseEntity<DroneCommandResponseDto> land(
            @PathVariable UUID droneId,
            Authentication authentication) {
        
        String username = authentication != null ? authentication.getName() : "anonymous";
        log.info("Land command for drone {} by user {}", droneId, username);
        
        DroneCommandResponseDto response = droneCommandService.land(droneId, username);
        return ResponseEntity.ok(response);
    }

    /**
     * Hover command
     * 
     * @param droneId the ID of the target drone
     * @param authentication the authenticated user (optional)
     * @return command response
     */
    @PostMapping("/hover")
    public ResponseEntity<DroneCommandResponseDto> hover(
            @PathVariable UUID droneId,
            Authentication authentication) {
        
        String username = authentication != null ? authentication.getName() : "anonymous";
        log.info("Hover command for drone {} by user {}", droneId, username);
        
        DroneCommandResponseDto response = droneCommandService.hover(droneId, username);
        return ResponseEntity.ok(response);
    }

    /**
     * Cancel a pending command
     * 
     * @param droneId the ID of the target drone (for path consistency)
     * @param commandId the ID of the command to cancel
     * @param authentication the authenticated user (optional)
     * @return operation result
     */
    @DeleteMapping("/{commandId}")
    public ResponseEntity<Map<String, Object>> cancelCommand(
            @PathVariable UUID droneId,
            @PathVariable String commandId,
            Authentication authentication) {
        
        String username = authentication != null ? authentication.getName() : "anonymous";
        log.info("Cancelling command {} for drone {} by user {}", 
                commandId, droneId, username);
        
        boolean success = droneCommandService.cancelCommand(commandId, username);
        
        Map<String, Object> response = Map.of(
                "success", success,
                "message", success ? "ÂëΩ‰ª§ÂèñÊ∂àÊàêÂäü" : "ÂëΩ‰ª§ÂèñÊ∂àÂ§±Ë¥•",
                "commandId", commandId,
                "droneId", droneId
        );
        
        return ResponseEntity.ok(response);
    }

    /**
     * Get command status
     * 
     * @param droneId the ID of the target drone (for path consistency)
     * @param commandId the ID of the command
     * @return command status
     */
    @GetMapping("/{commandId}")
    public ResponseEntity<DroneCommandDto> getCommandStatus(
            @PathVariable UUID droneId,
            @PathVariable String commandId) {
        
        log.debug("Getting status for command {} on drone {}", commandId, droneId);
        
        DroneCommandDto command = droneCommandService.getCommandStatus(commandId);
        
        if (command == null) {
            return ResponseEntity.notFound().build();
        }
        
        return ResponseEntity.ok(command);
    }

    /**
     * Get command history for a drone
     * 
     * @param droneId the ID of the target drone
     * @param limit maximum number of commands to return
     * @return command history
     */
    @GetMapping("/history")
    public ResponseEntity<List<DroneCommandDto>> getCommandHistory(
            @PathVariable UUID droneId,
            @RequestParam(defaultValue = "20") int limit) {
        
        log.debug("Getting command history for drone {} with limit {}", droneId, limit);
        
        List<DroneCommandDto> history = droneCommandService.getCommandHistory(droneId, limit);
        return ResponseEntity.ok(history);
    }

    /**
     * Get available command actions and their descriptions
     * 
     * @return available commands
     */
    @GetMapping("/available")
    public ResponseEntity<Map<String, Object>> getAvailableCommands() {
        Map<String, Object> commands = Map.of(
                "basic", Map.of(
                        DroneCommandDto.Actions.TAKEOFF, "Ëµ∑È£û",
                        DroneCommandDto.Actions.LAND, "ÈôçËêΩ",
                        DroneCommandDto.Actions.RETURN_TO_HOME, "ËøîËà™",
                        DroneCommandDto.Actions.HOVER, "ÊÇ¨ÂÅú",
                        DroneCommandDto.Actions.EMERGENCY_STOP, "Á¥ßÊÄ•ÂÅúÊ≠¢"
                ),
                "movement", Map.of(
                        DroneCommandDto.Actions.MOVE_TO, "ÁßªÂä®Âà∞ÊåáÂÆö‰ΩçÁΩÆ (ÈúÄË¶Å latitude, longitude ÂèÇÊï∞)",
                        DroneCommandDto.Actions.SET_ALTITUDE, "ËÆæÁΩÆÈ´òÂ∫¶ (ÈúÄË¶Å altitude ÂèÇÊï∞)",
                        DroneCommandDto.Actions.SET_SPEED, "ËÆæÁΩÆÈÄüÂ∫¶ (ÈúÄË¶Å speed ÂèÇÊï∞)",
                        DroneCommandDto.Actions.ROTATE, "ÊóãËΩ¨ (ÈúÄË¶Å angle ÂèÇÊï∞)"
                ),
                "mission", Map.of(
                        DroneCommandDto.Actions.START_MISSION, "ÂºÄÂßã‰ªªÂä°",
                        DroneCommandDto.Actions.PAUSE_MISSION, "ÊöÇÂÅú‰ªªÂä°",
                        DroneCommandDto.Actions.RESUME_MISSION, "ÊÅ¢Â§ç‰ªªÂä°",
                        DroneCommandDto.Actions.ABORT_MISSION, "‰∏≠Ê≠¢‰ªªÂä°"
                ),
                "configuration", Map.of(
                        DroneCommandDto.Actions.CALIBRATE, "Ê†°ÂáÜ‰º†ÊÑüÂô®",
                        DroneCommandDto.Actions.SET_HOME, "ËÆæÁΩÆËµ∑ÂßãÁÇπ",
                        DroneCommandDto.Actions.ENABLE_FAILSAFE, "ÂêØÁî®Â§±Êïà‰øùÊä§",
                        DroneCommandDto.Actions.DISABLE_FAILSAFE, "Á¶ÅÁî®Â§±Êïà‰øùÊä§"
                )
        );
        
        return ResponseEntity.ok(commands);
    }

    /**
     * Check if a drone is available for commands
     * 
     * @param droneId the ID of the target drone
     * @return availability status
     */
    @GetMapping("/availability")
    public ResponseEntity<Map<String, Object>> checkAvailability(@PathVariable UUID droneId) {
        boolean available = droneCommandService.isDroneAvailable(droneId);
        
        Map<String, Object> response = Map.of(
                "droneId", droneId,
                "available", available,
                "message", available ? "Êó†‰∫∫Êú∫ÂèØÁî®" : "Êó†‰∫∫Êú∫‰∏çÂèØÁî®ÊàñÁ¶ªÁ∫ø"
        );
        
        return ResponseEntity.ok(response);
    }
} 